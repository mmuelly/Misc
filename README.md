anagramfinder
=============

This program finds anagrams. When run, it prompts the user for a text file which should contain a list of words or phrases whose anagrams are to be found. An algorithm is then used to find anagrams which are subsequently written into a solution file. This solution includes anagram words and phrases that can be formed with the original letters. The algorithm uses a dictionary available in the form of a de la Briandais trie built from a text file containing the dictionary words.
The basic algorithm used to obtain the anagrams is based on a recursive algorithm finding permutations. Two vectors are important in understanding the basics of this algorithm. The first vector, called word, contains the initial characters of the string. The second vector, called perm, begins empty and will be built and rebuilt along the way to contain various permutations of word. When the function addLetter, which finds the anagrams, is called, the first existing letter in word is removed and placed in the first empty position of the vector perm.  At this point the string contained in perm is checked against the dictionary. There are three possible cases: 

1. The string is a valid prefix. In this case the algorithm is called with both the word and the perm vectors to see if a word can be made with the remaining letters from word.
2. The string is a word. First, it is determined whether all the letters in word have been used. If word still contains any letters, then two cases have to be covered. 
a. It might be possible that the shorter word is a prefix of a longer one and therefore a recursive call similar to that in case #1 above is made. 
b. At the same time it is assumed that a word has been found, and perhaps other words can be found within the remaining letters to find a multiple word anagram solution. The word is added to a third vector, called partial. Empty vector elements are then removed from the vectors word and perm since all those letters have been used for the word found. Then a new call is made with the new word, perm, and partial vectors. On the other hand, if all the letters in word have been used, then the new word found, which was built in perm, is added to the vector partial which is then added to the set of solutions. 
3. The string is neither a word nor a valid prefix. In this case we do not want to further exhaust the possibilities starting with the prefix because no possible permutations would be found. Therefore, no recursive calls are made.

In the backtracking portion of the program, the letter that had been removed from the word vector and added to the perm vector is then put back in its original place. In the next run of the loop, the same thing is done with the next letter available as before and all the appropriate sub calls are made, as discussed above. This is done until each letter from word has been used in the first available position of perm in that call. Through the sub-calls that are made, the available position in perm will move up one as it goes one step deeper into the recursive process. Then the for-loop in a sub-call will have each letter be placed into that position as well.
The algorithm improves runtime of finding valid anagrams for the average case. Big O of the algorithm is O(N!) since all possible permutations might be checked. The actual complexity, however, can range from θ(N), if no words in the dictionary start with the letters in the string, to θ(N!) in the case were all possible permutations are found in the dictionary. Hence, the actual complexity of the algorithm is very dependent on the dictionary in use.
Empirical data shows that this is a considerable improvement compared to a simple permutation algorithm. Given the string “elbarcbs” the algorithm checked a total number of 7,704 strings against the dictionary. Using simply all possible permutations the string would require 40,320 checks against the dictionary. This means the algorithm reduced the number of checks to 19% of the original value.